{
  "title": "Claude Code Hooks Lifecycle Assessment",
  "description": "Assessment covering Claude Code hooks architecture, lifecycle events, blocking mechanisms, and implementation best practices for virtual assistant candidates.",
  "isQuiz": true,
  "domain": "Hooks & Automation",
  "weight": 0.20,
  "questions": [
    {
      "questionNumber": 0,
      "questionText": "What is the primary purpose of Claude Code hooks?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "To replace Claude's built-in tools with custom implementations",
        "To execute shell commands at specific lifecycle events for validation, automation, and control",
        "To modify Claude's underlying language model behavior",
        "To disable Claude Code's security features"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "To execute shell commands at specific lifecycle events for validation, automation, and control",
      "explanation": "WHY THIS MATTERS: Hooks are Claude Code's extension mechanism for power users. Unlike prompting (which guides Claude's decisions), hooks provide deterministic control - they execute YOUR code at specific lifecycle points. This enables validation that AI can't bypass, automated logging that survives context resets, and safety guardrails enforced by your infrastructure. Think of hooks as the 'hard rules' layer beneath Claude's 'soft reasoning' layer.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Hooks Reference",
              "url": "https://code.claude.com/docs/en/hooks",
              "section": "Hook lifecycle",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Hooks fire at specific points during a Claude Code session."
          }
        ]
      }
    },
    {
      "questionNumber": 1,
      "questionText": "When does the UserPromptSubmit hook fire?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "After Claude processes the prompt",
        "When you submit a prompt, BEFORE Claude processes it",
        "When Claude finishes responding",
        "When the session ends"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "When you submit a prompt, BEFORE Claude processes it",
      "explanation": "WHY THIS MATTERS: This hook intercepts user input BEFORE Claude sees it. This timing is critical - you can validate prompts (block certain keywords), inject context (add today's date automatically), or log everything for compliance. The 'before processing' timing means you're modifying what Claude receives, not reacting to what it does. It's your first line of defense and customization.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Hooks Reference",
              "url": "https://code.claude.com/docs/en/hooks",
              "onlineUrl": "https://code.claude.com/docs/en/hooks",
              "section": "UserPromptSubmit",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Runs when the user submits a prompt, before Claude processes it. This allows you to add additional context based on the prompt/conversation, validate prompts, or block certain types of prompts."
          }
        ]
      }
    },
    {
      "questionNumber": 2,
      "questionText": "Which hooks CAN block execution (prevent an action from proceeding)?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Only PreToolUse and PostToolUse",
        "UserPromptSubmit, PreToolUse, PermissionRequest, PostToolUse, PostToolUseFailure, SubagentStop, and Stop",
        "All hook types can block",
        "Only Stop and SessionEnd"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "UserPromptSubmit, PreToolUse, PermissionRequest, PostToolUse, PostToolUseFailure, SubagentStop, and Stop",
      "explanation": "WHY THIS MATTERS: Understanding which hooks CAN block is fundamental to hook architecture. 'Hard' blocks prevent actions entirely (PreToolUse can stop rm -rf before it runs). 'Soft' blocks (PostToolUse) can only alert Claude after the fact - the damage is done. Know the difference: put safety checks in PreToolUse, put logging in PostToolUse. The hooks that CAN'T block (SessionStart, SessionEnd) are for observation only.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Hooks Reference",
              "url": "https://code.claude.com/docs/en/hooks",
              "onlineUrl": "https://code.claude.com/docs/en/hooks",
              "section": "Exit Code 2 Behavior",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Exit code 2: Blocking error. Only stderr is used as the error message and fed back to Claude. PreToolUse: Blocks the tool call, shows stderr to Claude. UserPromptSubmit: Blocks prompt processing, erases prompt. Stop: Blocks stoppage, shows stderr to Claude."
          }
        ]
      }
    },
    {
      "questionNumber": 3,
      "questionText": "How do hooks receive their input data?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Via environment variables like $TOOL_NAME and $COMMAND",
        "Via command-line arguments",
        "Via stdin as a JSON object",
        "Via a configuration file"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "Via stdin as a JSON object",
      "explanation": "WHY THIS MATTERS: stdin JSON is the standard Unix pattern for passing structured data to processes. This design means hooks can be written in any language (Python, Node, Bash with jq), and they receive rich context (session ID for logging, transcript path for analysis, cwd for relative operations). The JSON structure is stable across Claude Code versions, making hooks future-proof.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Hooks Reference",
              "url": "https://code.claude.com/docs/en/hooks",
              "onlineUrl": "https://code.claude.com/docs/en/hooks",
              "section": "Hook Input",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Hooks receive JSON data via stdin containing session information and event-specific data: { session_id: string, transcript_path: string, cwd: string, permission_mode: string, hook_event_name: string, ... }"
          }
        ]
      }
    },
    {
      "questionNumber": 4,
      "questionText": "What is the CORRECT way to reference a hook script in settings.json?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "\"command\": \"uv run $HOME/.claude/hooks/script.py\"",
        "\"command\": \"python3 $HOME/.claude/hooks/script.py\"",
        "\"command\": \"$HOME/.claude/hooks/script.py\"",
        "\"command\": \"./hooks/script.py\""
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "\"command\": \"$HOME/.claude/hooks/script.py\"",
      "explanation": "WHY THIS MATTERS: Direct paths with shebangs ensure hooks work regardless of environment (no PATH issues, no virtual environment confusion). CLAUDE_PROJECT_DIR lets you ship hooks with your project that work when teammates clone the repo. The chmod +x requirement catches permission errors at development time, not during critical operations. These patterns come from hard-won debugging sessions.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Hooks Reference",
              "url": "https://code.claude.com/docs/en/hooks",
              "onlineUrl": "https://code.claude.com/docs/en/hooks",
              "section": "Project-Specific Hook Scripts",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "You can use the environment variable CLAUDE_PROJECT_DIR (only available when Claude Code spawns the hook command) to reference scripts stored in your project, ensuring they work regardless of Claude's current directory."
          }
        ]
      }
    },
    {
      "questionNumber": 5,
      "questionText": "When does PostToolUse hook fire?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Only when a tool throws an unhandled exception",
        "After a tool completes successfully ONLY (NOT on errors)",
        "Before a tool executes, to validate parameters",
        "Immediately after the user grants permission"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "After a tool completes successfully ONLY (NOT on errors)",
      "explanation": "WHY THIS MATTERS: The split between PostToolUse (success) and PostToolUseFailure (failure) lets you handle outcomes differently. Log successful file edits to an audit trail in PostToolUse; alert on failed commands in PostToolUseFailure. If these were merged, you'd need conditional logic in every hook. The separation reflects that success and failure often require completely different handling.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Hooks Reference",
              "url": "https://code.claude.com/docs/en/hooks",
              "onlineUrl": "https://code.claude.com/docs/en/hooks",
              "section": "PostToolUse",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "PostToolUse: Runs immediately after a tool completes successfully. PostToolUseFailure: After tool fails."
          }
        ]
      }
    },
    {
      "questionNumber": 6,
      "questionText": "For PostToolUse hooks, what is required for Claude to see your message?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Output {\"reason\": \"your message\"}",
        "Output {\"additionalContext\": \"your message\"}",
        "Output {\"decision\": \"block\", \"reason\": \"your message\"}",
        "Write to stdout with plain text"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "Output {\"decision\": \"block\", \"reason\": \"your message\"}",
      "explanation": "WHY THIS MATTERS: This is a common source of confusion. 'decision: block' in PostToolUse doesn't undo the tool call - the file is already edited. What it does is make Claude NOTICE your message (the 'reason' field). Without 'block', your output is silently ignored. Use 'additionalContext' for info Claude should consider but doesn't require acknowledgment. This visibility pattern evolved from hooks whose warnings were lost.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Hooks Reference",
              "url": "https://code.claude.com/docs/en/hooks",
              "onlineUrl": "https://code.claude.com/docs/en/hooks",
              "section": "PostToolUse Decision Control",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "'block' automatically prompts Claude with reason. undefined does nothing. reason is ignored. hookSpecificOutput.additionalContext adds context for Claude to consider."
          }
        ]
      }
    },
    {
      "questionNumber": 7,
      "questionText": "What is the RECOMMENDED execution time for hooks to ensure responsive UX? (Note: Official timeout is 60 seconds)",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Under 1 second",
        "Under 100 milliseconds (best practice)",
        "Under 5 seconds",
        "60 seconds (official timeout)"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Under 100 milliseconds (best practice)",
      "explanation": "WHY THIS MATTERS: The 60-second timeout is a safety net, not a target. Every millisecond your hook runs is a millisecond the user waits with a frozen UI. At 100ms, delays are imperceptible; at 500ms, users notice; at 2 seconds, they think something's broken. Fast hooks maintain the 'vibe coding' flow. If you need heavy processing, consider async patterns: write to a file and have a background process handle it.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Hooks Reference",
              "url": "https://code.claude.com/docs/en/hooks",
              "onlineUrl": "https://code.claude.com/docs/en/hooks",
              "section": "Hook Execution Details",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Timeout: 60-second execution limit by default, configurable per command. A timeout for an individual command does not affect the other commands."
          }
        ]
      }
    },
    {
      "questionNumber": 8,
      "questionText": "What does exit code 2 mean in a hook script?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Success - allow the action",
        "Non-blocking error",
        "Hard block - cannot be bypassed",
        "Soft block - user can override"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "Hard block - cannot be bypassed",
      "explanation": "WHY THIS MATTERS: Exit codes are your hook's primary communication channel. Exit 0 = 'proceed, here's optional JSON data.' Exit 2 = 'STOP, something is wrong, here's why (in stderr).' Other codes = 'there was an issue but don't stop everything.' This convention lets hooks enforce hard constraints (exit 2 for dangerous operations) while gracefully handling recoverable errors (exit 1 for warnings).",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Hooks Reference",
              "url": "https://code.claude.com/docs/en/hooks",
              "onlineUrl": "https://code.claude.com/docs/en/hooks",
              "section": "Simple: Exit Code",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Exit code 0: Success. Exit code 2: Blocking error. Only stderr is used as the error message and fed back to Claude. JSON in stdout is NOT processed for exit code 2. Other exit codes: Non-blocking error."
          }
        ]
      }
    },
    {
      "questionNumber": 9,
      "questionText": "In Stop hooks, what does {\"continue\": false} actually do?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Allows Claude to stop normally",
        "Prevents Claude from stopping (forces continuation)",
        "Halts Claude entirely (emergency stop)",
        "Has no effect"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "Halts Claude entirely (emergency stop)",
      "explanation": "WHY THIS MATTERS: The Stop hook controls session termination. 'continue: false' is an emergency brake - use it when you detect something critically wrong that needs human attention before ANY more AI actions. 'decision: block' with a reason keeps Claude working - useful for 'you're not done yet, the tests still fail.' Empty JSON {} allows normal completion. This granularity lets you implement sophisticated session management.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Hooks Reference",
              "url": "https://code.claude.com/docs/en/hooks",
              "onlineUrl": "https://code.claude.com/docs/en/hooks",
              "section": "Stop/SubagentStop Decision Control",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "If continue is false, Claude stops processing after the hooks run. 'block' prevents Claude from stopping. You must populate reason for Claude to know how to proceed. undefined allows Claude to stop."
          }
        ]
      }
    },
    {
      "questionNumber": 10,
      "questionText": "What is headless mode in Claude Code and when would you use it?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Running Claude without a display for accessibility",
        "Non-interactive mode for CI/CD pipelines and automation scripts",
        "A low-resource mode for slow computers",
        "Running multiple Claude instances simultaneously"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Non-interactive mode for CI/CD pipelines and automation scripts",
      "explanation": "WHY THIS MATTERS: Headless mode transforms Claude Code from an interactive assistant into an automation tool. In CI/CD, you can have Claude review PRs, generate documentation, or run code analysis - all without human interaction. This enables 'Claude as a service' patterns where automated workflows invoke Claude for specific tasks. It's the bridge between interactive coding and automated pipelines.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code CLI Reference",
              "url": "https://code.claude.com/docs/en/cli-reference",
              "onlineUrl": "https://code.claude.com/docs/en/cli-reference",
              "section": "Headless Mode",
              "accessDate": "2026-01-30"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Headless mode enables non-interactive execution for CI/CD pipelines, automation scripts, and programmatic access to Claude Code capabilities."
          }
        ]
      }
    },
    {
      "questionNumber": 11,
      "questionText": "How do you run Claude Code in headless mode with a prompt?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "claude --headless \"your prompt\"",
        "claude -p \"your prompt\"",
        "echo \"your prompt\" | claude --no-interactive",
        "claude run \"your prompt\""
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "claude -p \"your prompt\"",
      "explanation": "WHY THIS MATTERS: The -p flag is the gateway to automation. Combined with --output-format json, you get structured results for parsing. Combined with --allowedTools, you control exactly what Claude can do. This simple flag unlocks use cases from automated code review to scheduled documentation updates to integration testing. Master -p and you unlock Claude as a programmable service.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code CLI Reference",
              "url": "https://code.claude.com/docs/en/cli-reference",
              "onlineUrl": "https://code.claude.com/docs/en/cli-reference",
              "section": "Command Line Options",
              "accessDate": "2026-01-30"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Use -p or --prompt to run Claude Code in headless mode with a specified prompt, without starting the interactive interface."
          }
        ]
      }
    },
    {
      "questionNumber": 12,
      "questionText": "What output format option is most useful for parsing Claude Code results in scripts?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "--output-format text (human readable)",
        "--output-format json (structured, machine parseable)",
        "--output-format markdown (documentation ready)",
        "--output-format xml (legacy compatibility)"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "--output-format json (structured, machine parseable)",
      "explanation": "WHY THIS MATTERS: JSON output turns Claude's responses into data you can programmatically process. Extract specific fields, check for errors, feed results into other tools. In a CI pipeline, you might parse JSON to determine if Claude found issues, what files were modified, or whether tests passed. This is the interface between Claude's intelligence and your automation infrastructure.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code CLI Reference",
              "url": "https://code.claude.com/docs/en/cli-reference",
              "onlineUrl": "https://code.claude.com/docs/en/cli-reference",
              "section": "Output Formats",
              "accessDate": "2026-01-30"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Use --output-format json for structured output that can be parsed by scripts and automation tools."
          }
        ]
      }
    }
  ]
}
