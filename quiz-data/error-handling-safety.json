{
  "title": "Error Handling & Safety Assessment",
  "description": "Assessment covering error recovery strategies, debugging workflows, sandbox awareness, and permission boundaries in Claude Code.",
  "isQuiz": true,
  "domain": "Error Handling + Safety",
  "weight": 0.35,
  "questions": [
    {
      "questionNumber": 0,
      "questionText": "When a Bash command exits with a non-zero exit code, what should you do?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Ignore it and continue with the next task",
        "Stop and acknowledge the failure, diagnose, then fix",
        "Retry the same command automatically",
        "Report to the user and wait for instructions"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Stop and acknowledge the failure, diagnose, then fix",
      "explanation": "WHY THIS MATTERS: Silent failures are the enemy of vibe coding. If a command fails and you proceed as if it succeeded, you build on a broken foundation. Claude Code's approach—stop, acknowledge, diagnose, fix—mirrors how senior engineers handle errors: never assume success, always verify. This is especially critical in AI-assisted workflows where errors can cascade quickly. The stderr output contains clues; use them before moving on.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Hooks Reference",
              "url": "https://github.com/Piebald-AI/claude-code-system-prompts",
              "onlineUrl": "https://code.claude.com/docs/en/hooks",
              "section": "Exit Codes",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Exit code 0: Success. Exit code 2: Blocking error. Other exit codes: Non-blocking error. stderr is shown to the user in verbose mode."
          }
        ]
      }
    },
    {
      "questionNumber": 1,
      "questionText": "What is the correct pattern for handling cd failures in shell scripts?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "cd /path/to/dir",
        "cd /path/to/dir || exit 1",
        "cd /path/to/dir 2>/dev/null",
        "if cd /path/to/dir; then echo 'ok'; fi"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "cd /path/to/dir || exit 1",
      "explanation": "WHY THIS MATTERS: 'cd' is notoriously dangerous in scripts—it can fail silently, and all subsequent commands run in the wrong directory. Imagine 'rm -rf *' executing in your home directory instead of a temp folder. The '|| exit 1' pattern is defensive programming that says 'if this fails, stop everything.' In vibe coding, where AI generates shell commands rapidly, these guardrails prevent catastrophic mistakes from compounding.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code CLI Reference",
              "url": "https://github.com/Piebald-AI/claude-code-system-prompts",
              "onlineUrl": "https://code.claude.com/docs/en/cli-reference",
              "section": "Bash tool - Directory Verification",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "If the command will create new directories or files, first use ls to verify the parent directory exists and is the correct location."
          }
        ]
      }
    },
    {
      "questionNumber": 2,
      "questionText": "When writing Python code, which exception handling pattern is WRONG?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "except ValueError as e: logging.error(f'Invalid: {e}'); raise",
        "except Exception as e: logging.debug(f'Caught: {e}')",
        "except (TypeError, KeyError) as e: handle_error(e)",
        "except SpecificError: logger.warning('Known issue'); return default"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "except Exception as e: logging.debug(f'Caught: {e}')",
      "explanation": "WHY THIS MATTERS: 'except Exception: pass' and 'except Exception: log.debug()' are silent failure patterns that hide bugs. The error happened, but you'll never know because DEBUG logs are often filtered out. AI-generated code sometimes introduces these anti-patterns to appear 'robust.' Real robustness means catching SPECIFIC exceptions you can handle, logging at appropriate levels (error for errors!), and re-raising what you can't handle. Silent failures are technical debt.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Security Reference",
              "url": "https://github.com/Piebald-AI/claude-code-system-prompts",
              "onlineUrl": "https://code.claude.com/docs/en/security",
              "section": "Security best practices",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Be careful not to introduce security vulnerabilities. Review all suggested changes before approval."
          }
        ]
      }
    },
    {
      "questionNumber": 3,
      "questionText": "What is the risk of using subprocess.run() without check=True in Python?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "You must manually check returncode afterward",
        "The command output is not captured",
        "Non-zero exit codes are silently ignored",
        "The subprocess runs in a separate thread"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "Non-zero exit codes are silently ignored",
      "explanation": "WHY THIS MATTERS: Python's subprocess.run() has a dangerous default: it returns success even when the command fails. Your code happily continues, unaware that the build failed, the test crashed, or the deployment bombed. The check=True parameter changes this—failures raise CalledProcessError, forcing you to handle them. This is a classic silent failure pattern that Claude Code hooks can detect. Always use check=True unless you have a specific reason to handle failures manually.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Security Reference",
              "url": "https://github.com/Piebald-AI/claude-code-system-prompts",
              "onlineUrl": "https://code.claude.com/docs/en/security",
              "section": "Security best practices",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Review all suggested changes before approval. Always maintain good security practices when working with any AI tool."
          }
        ]
      }
    },
    {
      "questionNumber": 4,
      "questionText": "Claude Code runs in a sandbox. What does this mean for file operations?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "You cannot access any files on the system",
        "Files outside the working directory are completely inaccessible",
        "You can access the filesystem but with user-level permissions",
        "All file operations require explicit user approval"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "You can access the filesystem but with user-level permissions",
      "explanation": "WHY THIS MATTERS: Claude Code's security model is 'user-level permissions with write restrictions.' You can READ anywhere the user can (system libs, other projects), but WRITES are confined to the working directory. This prevents accidental system-wide damage while enabling useful cross-project reading. Understanding this boundary is critical—don't assume you can modify files outside the project, but DO leverage read access for context gathering. It's a pragmatic balance between safety and usefulness.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Security Reference",
              "url": "https://code.claude.com/docs/en/security",
              "onlineUrl": "https://code.claude.com/docs/en/security",
              "section": "Permission-based architecture",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Claude Code can only write to the folder where it was started and its subfolders—it cannot modify files in parent directories without explicit permission. While Claude Code can read files outside the working directory (useful for accessing system libraries and dependencies), write operations are strictly confined to the project scope."
          }
        ]
      }
    },
    {
      "questionNumber": 5,
      "questionText": "Which git operations should you NEVER do without explicit user request?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "git status, git diff",
        "git add, git log",
        "git push --force, git reset --hard",
        "git branch, git checkout"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "git push --force, git reset --hard",
      "explanation": "WHY THIS MATTERS: 'git push --force' rewrites history and can destroy teammates' work. 'git reset --hard' discards uncommitted changes forever. These operations are irreversible and have caused countless lost hours. AI making these decisions autonomously would be catastrophic. Claude Code's rule is absolute: destructive git operations require explicit user request. This isn't about capability—it's about respecting that some actions have consequences AI shouldn't decide unilaterally.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Best Practices",
              "url": "https://github.com/Piebald-AI/claude-code-system-prompts",
              "onlineUrl": "https://docs.anthropic.com/en/docs/claude-code/best-practices",
              "section": "Git Safety Protocol",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "NEVER run destructive git commands (push --force, reset --hard, checkout ., restore ., clean -f, branch -D) unless the user explicitly requests these actions."
          }
        ]
      }
    },
    {
      "questionNumber": 6,
      "questionText": "When should you commit changes to git?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "After every file change",
        "At the end of each session",
        "Only when the user explicitly asks",
        "After completing each feature"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "Only when the user explicitly asks",
      "explanation": "WHY THIS MATTERS: Commits are checkpoints in history—they should be intentional, not automatic. Users have different workflows: some squash commits, some use conventional commits, some want to test before committing. AI auto-committing after every change creates messy history and removes user control. The 'only commit when asked' rule respects user autonomy. If you're unsure whether to commit, ask. This evolved from feedback that proactive commits felt invasive.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Best Practices",
              "url": "https://github.com/Piebald-AI/claude-code-system-prompts",
              "onlineUrl": "https://docs.anthropic.com/en/docs/claude-code/best-practices",
              "section": "Git Safety Protocol",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Only create commits when requested by the user. If unclear, ask first. NEVER commit changes unless the user explicitly asks you to."
          }
        ]
      }
    },
    {
      "questionNumber": 7,
      "questionText": "You notice code that might contain a security vulnerability (e.g., SQL injection). What should you do?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Fix it silently to avoid alarming the user",
        "Point it out and offer to fix it",
        "Ignore it - security is not your concern",
        "Stop all work until it's addressed"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Point it out and offer to fix it",
      "explanation": "WHY THIS MATTERS: Security vulnerabilities need visibility, not silent fixes. If you fix SQL injection without telling the user, they won't understand the risk their code had, won't audit for similar issues, and won't learn to prevent them. The correct approach: flag it clearly, explain the risk, offer to fix, but let the user acknowledge the issue. This creates teachable moments and maintains user awareness. Silent fixes, while well-intentioned, keep users in the dark about their codebase's security posture.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Security Reference",
              "url": "https://github.com/Piebald-AI/claude-code-system-prompts",
              "onlineUrl": "https://code.claude.com/docs/en/security",
              "section": "Security best practices",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Review all suggested changes before approval. Use project-specific permission settings for sensitive repositories. Always maintain good security practices when working with any AI tool."
          }
        ]
      }
    },
    {
      "questionNumber": 8,
      "questionText": "What should you do before running a command that modifies many files (like a mass rename)?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Just run it - Claude Code has undo capability",
        "Explain the scope and get confirmation from the user",
        "Create a backup of every file first",
        "Test on one file then automatically do the rest"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Explain the scope and get confirmation from the user",
      "explanation": "WHY THIS MATTERS: Bulk operations are high-risk—a typo in a regex could rename hundreds of files incorrectly. Unlike single-file edits where mistakes are contained, mass operations can create chaos that's hard to untangle. Before running any bulk operation, clearly state: 'This will affect N files matching pattern X.' Let the user confirm. This transparency prevents the 'wait, I didn't want THAT' moment. The user bears responsibility for approving scope; AI bears responsibility for clearly communicating it.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Security Reference",
              "url": "https://github.com/Piebald-AI/claude-code-system-prompts",
              "onlineUrl": "https://code.claude.com/docs/en/security",
              "section": "User responsibility",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Claude Code only has the permissions you grant it. You're responsible for reviewing proposed code and commands for safety before approval."
          }
        ]
      }
    },
    {
      "questionNumber": 9,
      "questionText": "What is the correct approach when the user provides a path that doesn't exist?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Create it automatically and continue",
        "Fail silently and skip that operation",
        "Inform the user and ask how to proceed",
        "Guess what they meant and use a similar path"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "Inform the user and ask how to proceed",
      "explanation": "WHY THIS MATTERS: Path typos happen. If the user says '/src/componenets/' (misspelled), auto-creating that directory means their code ends up in the wrong place and they waste time wondering why imports fail. The correct approach: surface the issue immediately. 'That path doesn't exist. Did you mean /src/components/? Or should I create /src/componenets/?' This catches mistakes early. Never guess or silently create—what seems helpful often causes confusion down the line.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code CLI Reference",
              "url": "https://github.com/Piebald-AI/claude-code-system-prompts",
              "onlineUrl": "https://code.claude.com/docs/en/cli-reference",
              "section": "Bash tool - Directory Verification",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "If the command will create new directories or files, first use ls to verify the parent directory exists and is the correct location."
          }
        ]
      }
    }
  ]
}
