{
  "title": "Claude Code Agents Deep Dive Assessment",
  "description": "Advanced assessment covering pre-defined vs on-demand agents, context gatekeeping anti-patterns, skills vs subagents architecture, and Anthropic's core principles for effective agents.",
  "isQuiz": true,
  "domain": "Advanced Architecture",
  "weight": 0.20,
  "questions": [
    {
      "questionNumber": 0,
      "questionText": "What distinguishes pre-defined agents from on-demand subagents in Claude Code?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Pre-defined agents are faster to execute",
        "Pre-defined agents auto-trigger based on patterns, on-demand subagents are explicitly spawned",
        "Pre-defined agents have access to more tools",
        "Pre-defined agents run in the background"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Pre-defined agents auto-trigger based on patterns, on-demand subagents are explicitly spawned",
      "explanation": "WHY THIS MATTERS: This distinction affects how you design your workflow. Pre-defined agents are like 'specialists on call' - when the right situation arises, they activate automatically. On-demand subagents are like 'contracted help' - you explicitly spawn them for specific tasks. Pre-defined agents reduce cognitive load (you don't have to remember to invoke them), while on-demand gives precise control. Choose based on how predictable your needs are.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Sub-agents",
              "url": "https://docs.anthropic.com/en/docs/claude-code/sub-agents",
              "onlineUrl": "https://docs.anthropic.com/en/docs/claude-code/sub-agents",
              "section": "Pre-defined agents",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Pre-defined agents are stored in your project's .claude/agents/ directory. When Claude detects that a task matches an agent's capabilities, it automatically activates that agent."
          }
        ]
      }
    },
    {
      "questionNumber": 1,
      "questionText": "Where are Claude Code pre-defined agents stored?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "~/.claude/skills/",
        "~/.claude/plugins/",
        ".claude/agents/ in project root",
        "~/.config/claude/agents/"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": ".claude/agents/ in project root",
      "explanation": "WHY THIS MATTERS: Project-root storage (.claude/agents/) means agents are version-controlled with your code. When teammates clone the repo, they get the same specialized agents. This is intentionally different from skills (which can be global). Project-specific agents encode project-specific knowledge that shouldn't leak to other codebases.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Sub-agents",
              "url": "https://docs.anthropic.com/en/docs/claude-code/sub-agents",
              "onlineUrl": "https://docs.anthropic.com/en/docs/claude-code/sub-agents",
              "section": "Pre-defined agents",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Pre-defined agents are stored in your project's .claude/agents/ directory."
          }
        ]
      }
    },
    {
      "questionNumber": 2,
      "questionText": "What happens when a pre-defined agent's trigger pattern matches a user request?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "User is prompted to approve activation",
        "Agent auto-activates without explicit user request",
        "Main agent pauses execution",
        "Session terminates for safety"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Agent auto-activates without explicit user request",
      "explanation": "WHY THIS MATTERS: Auto-activation creates seamless experiences. Instead of 'please use the migration agent,' you just say 'migrate the database schema' and Claude recognizes the pattern. This reduces friction and cognitive load - you describe what you want, and the right specialist appears. The magic is in the trigger patterns, which let you define precisely when each agent should activate.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Sub-agents",
              "url": "https://docs.anthropic.com/en/docs/claude-code/sub-agents",
              "onlineUrl": "https://docs.anthropic.com/en/docs/claude-code/sub-agents",
              "section": "Pre-defined agents",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "When Claude detects that a task matches an agent's capabilities, it automatically activates that agent."
          }
        ]
      }
    },
    {
      "questionNumber": 3,
      "questionText": "What is the 'context gatekeeping' anti-pattern in multi-agent systems?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Limiting token usage to save costs",
        "Restricting tool access for security",
        "Subagents hiding context from the main orchestrator",
        "Caching conversation history for performance"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "Subagents hiding context from the main orchestrator",
      "explanation": "WHY THIS MATTERS: This is the #1 anti-pattern in multi-agent systems. Imagine a research agent finding a security vulnerability but summarizing it as 'minor issues found.' The orchestrator never learns the severity, so the final response downplays a critical problem. Context gatekeeping happens accidentally when subagents over-summarize. The fix: subagents should report findings with enough detail for the parent to make informed decisions.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "research",
              "title": "Building a Multi-Agent Research System",
              "url": "https://www.anthropic.com/research/building-a-multi-agent-research-system",
              "onlineUrl": "https://www.anthropic.com/research/building-a-multi-agent-research-system",
              "section": "Coordinator Design",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "The coordinator agent needs visibility into all research findings to synthesize a coherent response. Subagents that hide context prevent holistic decision-making."
          }
        ]
      }
    },
    {
      "questionNumber": 4,
      "questionText": "Why does context gatekeeping reduce agent effectiveness?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Increases latency significantly",
        "Uses more tokens than necessary",
        "Prevents holistic reasoning across domain boundaries",
        "Causes memory leaks in long sessions"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "Prevents holistic reasoning across domain boundaries",
      "explanation": "WHY THIS MATTERS: The value of a coordinator is drawing connections across domains - 'the auth system and the payment system both have this vulnerability.' If subagents only report isolated findings, the coordinator becomes a dumb aggregator. Holistic reasoning requires holistic visibility. This is why simpler architectures (single agent with full context) often outperform complex multi-agent systems with context loss.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "research",
              "title": "Building a Multi-Agent Research System",
              "url": "https://www.anthropic.com/research/building-a-multi-agent-research-system",
              "onlineUrl": "https://www.anthropic.com/research/building-a-multi-agent-research-system",
              "section": "Coordinator Design",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "The coordinator agent needs visibility into all research findings to synthesize a coherent response that draws connections across domains."
          }
        ]
      }
    },
    {
      "questionNumber": 5,
      "questionText": "What is the recommended alternative to context gatekeeping?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Use more subagents for parallelism",
        "Keep context in main agent, use subagents only for isolated subtasks",
        "Increase context window size",
        "Implement caching layers between agents"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Keep context in main agent, use subagents only for isolated subtasks",
      "explanation": "WHY THIS MATTERS: The key word is 'isolated.' If subtasks are truly independent (scan these 5 repos for vulnerabilities), parallelization helps without context loss. But if subtasks inform each other (understand the architecture THEN plan the migration), running them in parallel loses the dependency. Default to keeping context in the main agent; only split when tasks are genuinely independent.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Building Effective Agents",
              "url": "https://www.anthropic.com/engineering/building-effective-agents",
              "onlineUrl": "https://www.anthropic.com/engineering/building-effective-agents",
              "section": "Agent architectures",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "The simplest architecture is a single agent that handles all tasks. For more complex scenarios, use orchestrator patterns where subagents handle isolated subtasks and report back."
          }
        ]
      }
    },
    {
      "questionNumber": 6,
      "questionText": "In the Multi-Agent Research System design, what was the key insight about subagent coordination?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Parent agent must see and synthesize all findings",
        "Each subagent should operate independently without coordination",
        "Subagents should communicate directly with each other",
        "Results should be aggregated externally"
      ],
      "correctAnswerIndex": 0,
      "correctAnswer": "Parent agent must see and synthesize all findings",
      "explanation": "WHY THIS MATTERS: Anthropic's multi-agent research system was their proving ground for these principles. The key insight: the coordinator seeing raw findings (not just summaries) let it connect dots that specialized agents missed individually. This is the architectural principle that should guide your multi-agent designs - synthesis happens at the top, not distributed across components.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "research",
              "title": "Building a Multi-Agent Research System",
              "url": "https://www.anthropic.com/research/building-a-multi-agent-research-system",
              "onlineUrl": "https://www.anthropic.com/research/building-a-multi-agent-research-system",
              "section": "System Architecture",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "The coordinator agent synthesizes findings from all research agents to produce a coherent final answer."
          }
        ]
      }
    },
    {
      "questionNumber": 7,
      "questionText": "What is the fundamental difference between skills and subagents in Claude Code?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Skills are faster to execute",
        "Skills use fewer tokens",
        "Skills run in main context, subagents have isolated context windows",
        "Skills require user approval"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "Skills run in main context, subagents have isolated context windows",
      "explanation": "WHY THIS MATTERS: This is the most important architectural distinction in Claude Code. Skills EXPAND your main context (the checklist stays visible, the template persists). Subagents ISOLATE work (the exploration noise goes away, only results return). Choose skills when visibility matters; choose subagents when clean context matters. Most users overuse subagents when skills would work better.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Skills",
              "url": "https://docs.anthropic.com/en/docs/claude-code/skills",
              "onlineUrl": "https://docs.anthropic.com/en/docs/claude-code/skills",
              "section": "Skills vs Subagents",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Skills run within the main conversation context, while subagents operate in isolated context windows with their own tool access."
          }
        ]
      }
    },
    {
      "questionNumber": 8,
      "questionText": "When should you use a skill instead of a subagent?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "For complex multi-step tasks requiring autonomy",
        "For checklists, templates, or context injection",
        "For parallel execution of independent tasks",
        "For background processing"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "For checklists, templates, or context injection",
      "explanation": "WHY THIS MATTERS: Think about what happens AFTER the skill/subagent runs. Checklists need to stay visible so Claude (and you) can check items off. Templates need to persist for reference. But exploration output? You don't want 50 file reads cluttering your context - just the insights. Match the mechanism to the persistence need: skills for reference material, subagents for working memory.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Skills",
              "url": "https://docs.anthropic.com/en/docs/claude-code/skills",
              "onlineUrl": "https://docs.anthropic.com/en/docs/claude-code/skills",
              "section": "When to use skills",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Use skills for context injection, checklists, and templates where you want the information to remain in the main conversation."
          }
        ]
      }
    },
    {
      "questionNumber": 9,
      "questionText": "What happens to skill context after execution?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "It remains in the main conversation context",
        "It is discarded after use",
        "It is saved to disk",
        "It is compressed for efficiency"
      ],
      "correctAnswerIndex": 0,
      "correctAnswer": "It remains in the main conversation context",
      "explanation": "WHY THIS MATTERS: Persistence has cost and benefit. Skill content consumes your context window for the entire session - good when you need ongoing reference, bad when it's one-time information. Subagent context disappears after the task - good for keeping main context clean, bad when you need to reference intermediate findings later. Design accordingly: inject what you'll reference repeatedly, isolate what you'll use once.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Skills",
              "url": "https://docs.anthropic.com/en/docs/claude-code/skills",
              "onlineUrl": "https://docs.anthropic.com/en/docs/claude-code/skills",
              "section": "Context persistence",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Skill content is injected into the main conversation context and remains available throughout the session."
          }
        ]
      }
    },
    {
      "questionNumber": 10,
      "questionText": "According to Anthropic, when is multi-agent architecture appropriate?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Always, for any complex task",
        "Only when truly parallel, independent subtasks exist",
        "When a single agent is too slow",
        "When the context window is limited"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Only when truly parallel, independent subtasks exist",
      "explanation": "WHY THIS MATTERS: Multi-agent adds complexity: coordination overhead, context synchronization challenges, harder debugging. The payoff is parallelism and specialization. For most Claude Code tasks, a single agent is faster and more reliable because it maintains full context and doesn't need coordination. Reserve multi-agent for genuinely parallel tasks (scan 10 repos) or extreme specialization needs.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Building Effective Agents",
              "url": "https://www.anthropic.com/engineering/building-effective-agents",
              "onlineUrl": "https://www.anthropic.com/engineering/building-effective-agents",
              "section": "When (not) to use agents",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Multi-agent systems can be appropriate when you have truly parallel, independent subtasks. For most applications, start with a single agent."
          }
        ]
      }
    },
    {
      "questionNumber": 11,
      "questionText": "What makes single-agent architecture preferable for most tasks?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Lower cost per request",
        "Simplicity, transparency, and holistic reasoning",
        "Faster execution speed",
        "Easier debugging"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Simplicity, transparency, and holistic reasoning",
      "explanation": "WHY THIS MATTERS: This is Anthropic's hard-won wisdom. They tried complex multi-agent systems and often found simpler single-agent approaches worked better. Why? Full context enables holistic reasoning (seeing connections), transparency makes debugging possible (one context to inspect), and simplicity reduces failure modes (no coordination bugs). Start simple, add complexity only when proven necessary.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Building Effective Agents",
              "url": "https://www.anthropic.com/engineering/building-effective-agents",
              "onlineUrl": "https://www.anthropic.com/engineering/building-effective-agents",
              "section": "Principles",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Maintain simplicity in your agentic system. Start with the simplest solution that could work, then add complexity only when needed."
          }
        ]
      }
    },
    {
      "questionNumber": 12,
      "questionText": "Multi-agent adds value when subtasks are what?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Sequential and dependent on each other",
        "Parallelizable and truly independent",
        "Simple and repetitive",
        "User-facing and interactive"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Parallelizable and truly independent",
      "explanation": "WHY THIS MATTERS: The test for multi-agent is simple: can these tasks run at the exact same time without talking to each other? If yes (scan 5 independent codebases), parallelize. If no (understand the code, THEN plan the refactor), don't. Forcing parallel execution on dependent tasks creates worse results than sequential single-agent work because you lose the dependency information.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Building Effective Agents",
              "url": "https://www.anthropic.com/engineering/building-effective-agents",
              "onlineUrl": "https://www.anthropic.com/engineering/building-effective-agents",
              "section": "Multi-agent patterns",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Multi-agent systems excel when you have independent, parallelizable subtasks that don't require shared state."
          }
        ]
      }
    },
    {
      "questionNumber": 13,
      "questionText": "What is Anthropic's first principle for building effective agents?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Maintain simplicity in agent design",
        "Maximize tool access",
        "Use the largest context window available",
        "Parallelize all operations"
      ],
      "correctAnswerIndex": 0,
      "correctAnswer": "Maintain simplicity in agent design",
      "explanation": "WHY THIS MATTERS: This principle fights the tendency to over-architect. 'I need a multi-agent system with specialized coordinators' often loses to 'I need a single Claude with a good CLAUDE.md file.' Complexity has costs: harder debugging, more failure modes, longer development time. Start simple. If it doesn't work, you've learned WHY you need complexity. If it does work, you've saved yourself massive overhead.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Building Effective Agents",
              "url": "https://www.anthropic.com/engineering/building-effective-agents",
              "onlineUrl": "https://www.anthropic.com/engineering/building-effective-agents",
              "section": "Principles for building effective agents",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Maintain simplicity in your agentic system. Start with the simplest solution that could work."
          }
        ]
      }
    },
    {
      "questionNumber": 14,
      "questionText": "What does 'transparency' mean in agent architecture according to Anthropic?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Showing all source code to users",
        "Agent actions and reasoning are visible and understandable",
        "Logging all API calls to a database",
        "Open-source licensing requirements"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Agent actions and reasoning are visible and understandable",
      "explanation": "WHY THIS MATTERS: Transparency enables debugging and builds trust. When something goes wrong, can you see WHY the agent made that decision? When it works, can you understand HOW so you can replicate it? Black-box agents that 'just work' become unmaintainable when they stop working. Claude Code's task tracking, verbose mode, and transcript logs all serve transparency - use them.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Building Effective Agents",
              "url": "https://www.anthropic.com/engineering/building-effective-agents",
              "onlineUrl": "https://www.anthropic.com/engineering/building-effective-agents",
              "section": "Principles for building effective agents",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Design for transparency: make agent actions and reasoning visible and understandable."
          }
        ]
      }
    },
    {
      "questionNumber": 15,
      "questionText": "What is ACI (Agent-Computer Interface) design?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Graphical user interface for agents",
        "Careful design of how agents interact with tools and environments",
        "API specification format",
        "Memory management protocol"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Careful design of how agents interact with tools and environments",
      "explanation": "WHY THIS MATTERS: Just as bad UX frustrates humans, bad ACI frustrates agents. If a tool returns cryptic errors, the agent can't recover. If tool descriptions are vague, the agent misuses them. Claude Code's tools are designed with ACI principles: clear error messages, consistent output formats, predictable behavior. When building custom tools or MCP servers, apply the same care you'd apply to human UX.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Building Effective Agents",
              "url": "https://www.anthropic.com/engineering/building-effective-agents",
              "onlineUrl": "https://www.anthropic.com/engineering/building-effective-agents",
              "section": "Agent-Computer Interface (ACI) design",
              "accessDate": "2026-01-24"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Just as good UI design is critical for human-computer interaction, ACI design is critical for agent-computer interaction."
          }
        ]
      }
    },
    {
      "questionNumber": 16,
      "questionText": "How do you toggle the task list view in Claude Code?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Type /tasks in the prompt",
        "Press Ctrl+T (or Cmd+T on Mac)",
        "Click the Tasks icon in the sidebar",
        "Run claude --tasks from the terminal"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Press Ctrl+T (or Cmd+T on Mac)",
      "explanation": "WHY THIS MATTERS: The task list is Claude Code's project management interface, showing up to 10 tasks with their status. Ctrl+T gives instant visibility into what Claude is tracking. This is especially valuable during complex multi-step work - you can see the plan, what's done, and what's blocked. It transforms Claude from a chat interface into a project dashboard.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Interactive Mode",
              "url": "https://code.claude.com/docs/en/interactive-mode",
              "onlineUrl": "https://code.claude.com/docs/en/interactive-mode",
              "section": "Task Management",
              "accessDate": "2026-01-30"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Press Ctrl+T to toggle the task list view, which displays up to 10 tasks with their current status."
          }
        ]
      }
    },
    {
      "questionNumber": 17,
      "questionText": "What is the correct format for TaskCreate's 'subject' vs 'activeForm' fields?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Both should use past tense (e.g., 'Fixed the bug')",
        "Subject: imperative (e.g., 'Fix the bug'), activeForm: present continuous (e.g., 'Fixing the bug')",
        "Subject: noun phrase (e.g., 'Bug fix'), activeForm: imperative (e.g., 'Fix the bug')",
        "Both should use present continuous (e.g., 'Fixing the bug')"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Subject: imperative (e.g., 'Fix the bug'), activeForm: present continuous (e.g., 'Fixing the bug')",
      "explanation": "WHY THIS MATTERS: This distinction serves different UI purposes. The 'subject' is the permanent task label - imperative verbs ('Add', 'Fix', 'Refactor') clearly state what needs doing. The 'activeForm' appears in the spinner while the task runs - present continuous ('Adding', 'Fixing') shows ongoing work. Getting this right makes the task list readable and the spinner informative.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Task Management",
              "url": "https://code.claude.com/docs/en/interactive-mode",
              "onlineUrl": "https://code.claude.com/docs/en/interactive-mode",
              "section": "TaskCreate",
              "accessDate": "2026-01-30"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Subject field uses imperative form ('Implement X', 'Add Y'), while activeForm uses present continuous ('Implementing X') for the spinner display."
          }
        ]
      }
    },
    {
      "questionNumber": 18,
      "questionText": "How do you share a task list across multiple Claude Code sessions?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Export tasks to a JSON file and import in each session",
        "Set CLAUDE_CODE_TASK_LIST_ID environment variable before launching",
        "Use the /share command within Claude Code",
        "Tasks are automatically shared across all sessions"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Set CLAUDE_CODE_TASK_LIST_ID environment variable before launching",
      "explanation": "WHY THIS MATTERS: Cross-session task sharing enables team workflows and persistent project tracking. By setting CLAUDE_CODE_TASK_LIST_ID=my-project before running claude, all sessions share the same task list. This is powerful for long-running projects where you work across multiple terminal windows or days. Tasks persist even when context is compacted.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Interactive Mode",
              "url": "https://code.claude.com/docs/en/interactive-mode",
              "onlineUrl": "https://code.claude.com/docs/en/interactive-mode",
              "section": "Cross-Session Tasks",
              "accessDate": "2026-01-30"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Share task lists across sessions with CLAUDE_CODE_TASK_LIST_ID=my-project claude."
          }
        ]
      }
    },
    {
      "questionNumber": 19,
      "questionText": "When should you NOT use the Task system in Claude Code?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "For multi-step implementation projects",
        "For single trivial fixes like typos or one-line changes",
        "When tracking dependencies between tasks",
        "During plan mode workflows"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "For single trivial fixes like typos or one-line changes",
      "explanation": "WHY THIS MATTERS: Tasks add overhead - creation, status updates, visibility in the UI. For a typo fix, this overhead exceeds the benefit. Use tasks when work benefits from tracking: multi-step projects, dependency chains, cross-session continuity. Skip tasks for quick fixes that complete in under 3 steps. The tool exists to organize complexity, not to bureaucratize simplicity.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Task Management",
              "url": "https://code.claude.com/docs/en/interactive-mode",
              "onlineUrl": "https://code.claude.com/docs/en/interactive-mode",
              "section": "When to Use Tasks",
              "accessDate": "2026-01-30"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Do not use tasks for single trivial fixes, pure research/exploration, or tasks completable in fewer than 3 steps."
          }
        ]
      }
    },
    {
      "questionNumber": 20,
      "questionText": "What happens when a skill and a slash command share the same name?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "An error is thrown and neither runs",
        "The slash command takes precedence",
        "The skill takes precedence",
        "The user is prompted to choose"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "The skill takes precedence",
      "explanation": "WHY THIS MATTERS: This precedence rule lets you override built-in behavior with custom skills. If you create a /commit skill, it runs instead of any built-in commit command. This design choice enables progressive customization - start with defaults, replace them as your workflow matures. It's the extensibility pattern that makes Claude Code adaptable to any team's conventions.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Skills",
              "url": "https://code.claude.com/docs/en/skills",
              "onlineUrl": "https://code.claude.com/docs/en/skills",
              "section": "Skills vs Commands",
              "accessDate": "2026-01-30"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "If a skill and a command share the same name, the skill takes precedence."
          }
        ]
      }
    },
    {
      "questionNumber": 21,
      "questionText": "Where are project-specific skills stored so teammates get them when cloning?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "~/.claude/skills/ (global home directory)",
        ".claude/skills/ (project root, version-controlled)",
        "~/.config/claude/skills/ (XDG config)",
        "package.json skills section"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": ".claude/skills/ (project root, version-controlled)",
      "explanation": "WHY THIS MATTERS: Project-root storage means skills travel with your code. When teammates clone, they get your custom /deploy, /test, and /review skills automatically. No manual setup, no drift between team members. This is 'team-shared commands via Git' - encode your workflow once, distribute it through your normal version control process.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Skills",
              "url": "https://code.claude.com/docs/en/skills",
              "onlineUrl": "https://code.claude.com/docs/en/skills",
              "section": "Skill Locations",
              "accessDate": "2026-01-30"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Project-specific skills in .claude/skills/ are version-controlled with your code, enabling team-shared commands via Git."
          }
        ]
      }
    },
    {
      "questionNumber": 22,
      "questionText": "What is the difference between global skills (~/.claude/skills/) and project skills (.claude/skills/)?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Global skills run faster",
        "Global skills apply to all projects, project skills only to the current repository",
        "Global skills have more permissions",
        "There is no functional difference"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Global skills apply to all projects, project skills only to the current repository",
      "explanation": "WHY THIS MATTERS: This scoping matches how developers think about tooling. Personal preferences (your /fmt skill for formatting) go global. Project conventions (your team's /deploy skill) go in the project. Global skills let you carry your workflow everywhere; project skills ensure everyone on the team follows the same procedures. Use both layers intentionally.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Skills",
              "url": "https://code.claude.com/docs/en/skills",
              "onlineUrl": "https://code.claude.com/docs/en/skills",
              "section": "Skill Scopes",
              "accessDate": "2026-01-30"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Global skills in ~/.claude/skills/ apply to all projects. Project skills in .claude/skills/ are scoped to the repository."
          }
        ]
      }
    },
    {
      "questionNumber": 23,
      "questionText": "How are slash commands and skills related in recent Claude Code versions?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "They are completely separate systems",
        "Slash commands call skills internally",
        "Skills and commands were merged - both create slash commands",
        "Skills replaced slash commands entirely"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "Skills and commands were merged - both create slash commands",
      "explanation": "WHY THIS MATTERS: This merge simplified the mental model. Previously, you had to know whether something was a 'command' or a 'skill.' Now, everything is a slash command - some are built-in, some come from skills. You invoke them the same way (/name), they appear in the same autocomplete list, and skills can override built-ins. One concept instead of two.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Skills",
              "url": "https://code.claude.com/docs/en/skills",
              "onlineUrl": "https://code.claude.com/docs/en/skills",
              "section": "Skills Overview",
              "accessDate": "2026-01-30"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Skills create slash commands that can be invoked with /skill-name. Built-in commands and skill-defined commands share the same invocation pattern."
          }
        ]
      }
    },
    {
      "questionNumber": 24,
      "questionText": "Why would you use a subagent for codebase research instead of having Claude read files directly?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Subagents are faster at reading files",
        "Subagents run in separate context windows and report back summaries, keeping your main conversation clean",
        "Subagents have special file permissions",
        "Direct file reading is not supported"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Subagents run in separate context windows and report back summaries, keeping your main conversation clean",
      "explanation": "WHY THIS MATTERS: When Claude researches a codebase, it reads many files that consume your context window. Subagents explore in their own context and report back findings as summaries. This preserves your main conversation's context for implementation while still getting comprehensive research. It's like having a research assistant who summarizes instead of reading aloud - you get the insights without the noise.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Building Effective Agents",
              "url": "https://www.anthropic.com/engineering/building-effective-agents",
              "onlineUrl": "https://www.anthropic.com/engineering/building-effective-agents",
              "section": "Subagent patterns",
              "accessDate": "2026-02-03"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Use subagents to investigate in a separate context, keeping your main conversation clean for implementation. They explore and report back findings."
          }
        ]
      }
    },
    {
      "questionNumber": 25,
      "questionText": "What workflow pattern does the Claude Code team recommend for building large features?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Start coding immediately and iterate based on errors",
        "Write comprehensive documentation before any code",
        "Start with a minimal spec, have Claude interview you for requirements, then execute in a new session",
        "Use parallel Claude instances to write all components simultaneously"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "Start with a minimal spec, have Claude interview you for requirements, then execute in a new session",
      "explanation": "WHY THIS MATTERS: This spec-based workflow uses AskUserQuestionTool to gather requirements iteratively. Claude interviews you about edge cases, constraints, and preferences you might not have considered. Then a fresh session executes the refined spec with clean context. This prevents the common pattern of accumulated context pollution during lengthy requirement discussions.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "social",
              "title": "Thariq (Claude Code team) on Twitter",
              "url": "https://x.com/trq212/status/2005315275026260309",
              "onlineUrl": "https://x.com/trq212/status/2005315275026260309",
              "section": "Thread",
              "accessDate": "2026-02-03"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Start with a minimal spec, ask Claude to interview you using AskUserQuestionTool, then make a new session to execute the spec."
          }
        ]
      }
    },
    {
      "questionNumber": 26,
      "questionText": "Why is the 'Writer/Reviewer' pattern with two Claude sessions effective for code quality?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Two sessions can process code twice as fast",
        "A fresh context avoids bias toward code the reviewing Claude didn't write",
        "Two Claude instances share the same memory and can collaborate",
        "The pattern is required for all code reviews in Claude Code"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "A fresh context avoids bias toward code the reviewing Claude didn't write",
      "explanation": "WHY THIS MATTERS: When Claude reviews code it just wrote, it's biased toward defending its own decisions. A fresh session with no memory of writing the code evaluates it objectively - like having a colleague review instead of self-review. This catches issues the writer-Claude rationalized away. Use separate worktrees or sessions for writing and reviewing.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Claude Code: Best practices for agentic coding",
              "url": "https://www.anthropic.com/engineering/claude-code-best-practices",
              "onlineUrl": "https://www.anthropic.com/engineering/claude-code-best-practices",
              "section": "Code Review",
              "accessDate": "2026-02-03"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "A fresh context improves code review since Claude won't be biased toward code it just wrote."
          }
        ]
      }
    },
    {
      "questionNumber": 27,
      "questionText": "What is the relationship between the 'Task' tool and 'TaskCreate' in Claude Code?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "They are the same tool with different names",
        "Task spawns subagents; TaskCreate manages work item tracking - different systems",
        "TaskCreate is a deprecated version of Task",
        "Task is for background jobs; TaskCreate is for foreground tasks"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Task spawns subagents; TaskCreate manages work item tracking - different systems",
      "explanation": "WHY THIS MATTERS: This naming collision causes common confusion. The Task tool spawns subagents with isolated context for parallel work. The Task* system (TaskCreate, TaskUpdate, TaskList, TaskGet) manages a visible work item list for tracking progress. They serve completely different purposes - one is for delegation, the other is for organization. Don't confuse launching a subagent with creating a todo item.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "github",
              "title": "GitHub Issue #22695",
              "url": "https://github.com/anthropics/claude-code/issues/22695",
              "onlineUrl": "https://github.com/anthropics/claude-code/issues/22695",
              "section": "Issue description",
              "accessDate": "2026-02-03"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Naming collision: Task tool vs Task* system. Task spawns subagents, while TaskCreate/TaskUpdate manage work item tracking."
          }
        ]
      }
    },
    {
      "questionNumber": 28,
      "questionText": "When you spawn a subagent via the Task tool, what happens to your permission allowlist?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "The subagent inherits all permissions from the parent session",
        "The subagent has NO inherited permissions - it operates with fresh permission state",
        "Only Bash permissions are inherited",
        "Permissions are inherited but with reduced scope"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "The subagent has NO inherited permissions - it operates with fresh permission state",
      "explanation": "WHY THIS MATTERS: This is a common source of unexpected permission prompts. When you've pre-approved certain tools in your main session, subagents don't inherit those approvals - they start fresh. This is intentional for security (subagents shouldn't automatically get elevated permissions), but surprising when your pre-approved commands suddenly prompt again inside a subagent.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "github",
              "title": "GitHub Issue #22665",
              "url": "https://github.com/anthropics/claude-code/issues/22665",
              "onlineUrl": "https://github.com/anthropics/claude-code/issues/22665",
              "section": "Issue description",
              "accessDate": "2026-02-03"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Subagent (Task tool) does not inherit permission allowlist from settings.json. Subagents operate with fresh permission state."
          }
        ]
      }
    }
  ]
}
