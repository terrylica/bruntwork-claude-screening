{
  "title": "Safety & Autonomy Assessment",
  "description": "Assessment covering permission boundaries, destructive operations, autonomy levels, and safety guardrails in Claude Code v2.1+.",
  "isQuiz": true,
  "domain": "Safety & Control",
  "weight": 0.20,
  "questions": [
    {
      "questionNumber": 0,
      "questionText": "What is Claude Code's default permission behavior?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "All operations are allowed automatically",
        "Asks permission for each action, with pre-approval available for known-safe operations",
        "No operations are allowed without admin approval",
        "Permissions depend on your subscription tier"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Asks permission for each action, with pre-approval available for known-safe operations",
      "explanation": "WHY THIS MATTERS: Claude Code's permission system balances safety with usability. By default, you approve each action, maintaining full control. As you build trust, use /permissions to pre-approve safe operations without constant interruption. This isn't about distrust - it's about visibility. Even experienced users appreciate knowing what's happening before irreversible changes occur.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Security Reference",
              "url": "https://code.claude.com/docs/en/security",
              "onlineUrl": "https://code.claude.com/docs/en/security",
              "section": "Permission-based architecture",
              "accessDate": "2026-01-25"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Claude Code uses strict read-only permissions by default. When additional actions are needed, Claude Code requests explicit permission. You can customize the allowlist to permit additional tools that you know are safe."
          }
        ]
      }
    },
    {
      "questionNumber": 1,
      "questionText": "What directory restriction applies to Claude Code write operations?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Can write anywhere on the system",
        "Can only write to the folder where it was started and subfolders",
        "Can only write to /tmp",
        "Cannot write any files"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Can only write to the folder where it was started and subfolders",
      "explanation": "WHY THIS MATTERS: This sandbox prevents accidental damage outside your project. Claude can read system libraries and other projects (useful for understanding patterns), but writes are confined to the working directory. This means a bug in Claude's reasoning can't corrupt unrelated projects or system files. The asymmetry is intentional: broad read access for context, narrow write access for safety.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Security Reference",
              "url": "https://code.claude.com/docs/en/security",
              "onlineUrl": "https://code.claude.com/docs/en/security",
              "section": "Permission-based architecture",
              "accessDate": "2026-01-25"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Claude Code can only write to the folder where it was started and its subfoldersâ€”it cannot modify files in parent directories without explicit permission. While Claude Code can read files outside the working directory (useful for accessing system libraries), write operations are strictly confined to the project scope."
          }
        ]
      }
    },
    {
      "questionNumber": 2,
      "questionText": "Which git operations should NEVER be done without explicit user request?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "git status, git diff",
        "git add, git log",
        "git push --force, git reset --hard, git clean -f",
        "git branch, git checkout"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "git push --force, git reset --hard, git clean -f",
      "explanation": "WHY THIS MATTERS: These commands are destructive and often irreversible. 'git push --force' can overwrite teammates' work. 'git reset --hard' discards uncommitted changes permanently. 'git clean -f' deletes untracked files. AI should never make these decisions autonomously - the consequences are too severe. Even experienced developers pause before running these commands.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Claude Code Best Practices",
              "url": "https://docs.anthropic.com/en/docs/claude-code/best-practices",
              "onlineUrl": "https://docs.anthropic.com/en/docs/claude-code/best-practices",
              "section": "Git Safety Protocol",
              "accessDate": "2026-01-25"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "NEVER run destructive git commands (push --force, reset --hard, checkout ., restore ., clean -f, branch -D) unless the user explicitly requests these actions."
          }
        ]
      }
    },
    {
      "questionNumber": 3,
      "questionText": "When should Claude Code commit changes to git?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Automatically after every file change",
        "At the end of each session",
        "Only when the user explicitly asks",
        "After completing each feature"
      ],
      "correctAnswerIndex": 2,
      "correctAnswer": "Only when the user explicitly asks",
      "explanation": "WHY THIS MATTERS: Commits are checkpoints in your project's history. Users have different workflows - some squash commits, some use conventional commits, some want to review changes before committing. AI auto-committing creates messy history and removes user control. The rule is simple: if you're unsure whether to commit, ask. This feedback evolved from users who found proactive commits invasive.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Claude Code Best Practices",
              "url": "https://docs.anthropic.com/en/docs/claude-code/best-practices",
              "onlineUrl": "https://docs.anthropic.com/en/docs/claude-code/best-practices",
              "section": "Git Safety Protocol",
              "accessDate": "2026-01-25"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Only create commits when requested by the user. If unclear, ask first. NEVER commit changes unless the user explicitly asks you to."
          }
        ]
      }
    },
    {
      "questionNumber": 4,
      "questionText": "What should happen BEFORE running a command that modifies many files?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Just run it - Claude Code has undo capability",
        "Explain the scope and get confirmation from the user",
        "Create a backup of every file first",
        "Test on one file then automatically do the rest"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Explain the scope and get confirmation from the user",
      "explanation": "WHY THIS MATTERS: Bulk operations multiply risk. A typo in a regex could rename hundreds of files incorrectly. Before any mass operation, clearly state: 'This will affect N files matching pattern X.' Let the user confirm scope. This transparency prevents the 'wait, I didn't want THAT' moment. The user bears responsibility for approving scope; AI bears responsibility for clearly communicating it.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Security Reference",
              "url": "https://code.claude.com/docs/en/security",
              "onlineUrl": "https://code.claude.com/docs/en/security",
              "section": "User responsibility",
              "accessDate": "2026-01-25"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Claude Code only has the permissions you grant it. You're responsible for reviewing proposed code and commands for safety before approval."
          }
        ]
      }
    },
    {
      "questionNumber": 5,
      "questionText": "You notice code with a potential SQL injection vulnerability. What should you do?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Fix it silently to avoid alarming the user",
        "Point it out and offer to fix it",
        "Ignore it - security is not Claude's concern",
        "Stop all work until it's addressed"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Point it out and offer to fix it",
      "explanation": "WHY THIS MATTERS: Security vulnerabilities need visibility, not silent fixes. If you fix SQL injection without telling the user, they won't understand the risk, won't audit for similar issues, and won't learn to prevent them. Flag it clearly, explain the risk, offer to fix, but let the user acknowledge the issue. This creates teachable moments and maintains user awareness of their codebase's security.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Security Reference",
              "url": "https://code.claude.com/docs/en/security",
              "onlineUrl": "https://code.claude.com/docs/en/security",
              "section": "Security best practices",
              "accessDate": "2026-01-25"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Review all suggested changes before approval. Use project-specific permission settings for sensitive repositories. Always maintain good security practices when working with any AI tool."
          }
        ]
      }
    },
    {
      "questionNumber": 6,
      "questionText": "What are the 3 levels of Claude Code autonomy control?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Free, Standard, Premium",
        "Approve each action, Pre-approve safe tools, Skip permissions entirely",
        "Read, Write, Execute",
        "View, Edit, Admin"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Approve each action, Pre-approve safe tools, Skip permissions entirely",
      "explanation": "WHY THIS MATTERS: You control how much autonomy Claude has. Default: approve each action (maximum safety). Intermediate: pre-approve known-safe tools via /permissions (balanced). Maximum: --dangerously-skip-permissions for isolated/trusted environments (use with caution). Choose based on your risk tolerance and environment. Higher autonomy = faster workflows but less oversight.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Claude Code: Best practices for agentic coding",
              "url": "https://www.anthropic.com/engineering/claude-code-best-practices",
              "onlineUrl": "https://www.anthropic.com/engineering/claude-code-best-practices",
              "section": "Controlling autonomy",
              "accessDate": "2026-01-25"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Users can toggle between: Asking permission for each tool use (default), Pre-approving safe tools via /permissions, Using --dangerously-skip-permissions for trusted workflows in isolated environments."
          }
        ]
      }
    },
    {
      "questionNumber": 7,
      "questionText": "What does 'supervised autonomy' mean for AI coding tools?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "A human watches every action in real-time",
        "You provide goals and guardrails, Claude executes, you approve/reject at decision points",
        "Claude asks permission for every single operation",
        "Multiple humans review all AI-generated code"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "You provide goals and guardrails, Claude executes, you approve/reject at decision points",
      "explanation": "WHY THIS MATTERS: Supervised autonomy is the sweet spot for productivity. You're not watching every file read, but you're approving destructive actions. You set the goal ('fix authentication'), Claude executes independently, and you review at checkpoints. This balance preserves safety while delivering substantial productivity gains - you're steering, not typing.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Claude Code 2.0 Best Practices",
              "url": "https://skywork.ai/blog/claude-code-2-0-best-practices-ai-coding-workflow-2025/",
              "onlineUrl": "https://skywork.ai/blog/claude-code-2-0-best-practices-ai-coding-workflow-2025/",
              "section": "2025 Updates",
              "accessDate": "2026-01-25"
            },
            "authority": {
              "tier": 2,
              "organization": "Community",
              "confidence": 0.90
            },
            "quotedText": "The most interesting practical tools in 2025 cluster around Level 3-4: supervised autonomy where you provide goals and guardrails, the agent executes independently, and you approve/reject at decision points. This balance preserves safety while delivering substantial productivity gains."
          }
        ]
      }
    },
    {
      "questionNumber": 8,
      "questionText": "What is the user's responsibility when using Claude Code?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "None - Claude handles everything safely",
        "Review proposed code and commands for safety before approval",
        "Only verify syntax correctness",
        "Write all the code manually"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Review proposed code and commands for safety before approval",
      "explanation": "WHY THIS MATTERS: AI is a powerful tool, not a replacement for human judgment. You approve what gets executed. You verify the logic makes sense. You catch the edge cases AI might miss. This isn't about distrust - it's about accountability. When you approve a command, you're taking responsibility for its effects. This shared responsibility model is what makes human-AI collaboration safe and effective.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Security Reference",
              "url": "https://code.claude.com/docs/en/security",
              "onlineUrl": "https://code.claude.com/docs/en/security",
              "section": "User responsibility",
              "accessDate": "2026-01-25"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Claude Code only has the permissions you grant it. You're responsible for reviewing proposed code and commands for safety before approval."
          }
        ]
      }
    },
    {
      "questionNumber": 9,
      "questionText": "What does Claude Code 4.5's 'overeagerness' tendency mean, and how should you address it?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "It runs too slowly - request faster execution",
        "It tends to overengineer by adding extra files and unnecessary abstractions",
        "It asks too many questions - tell it to proceed without asking",
        "It refuses to make changes - grant more permissions"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "It tends to overengineer by adding extra files and unnecessary abstractions",
      "explanation": "WHY THIS MATTERS: Claude Opus 4.5 sometimes creates extra files, adds unnecessary abstractions, or builds in flexibility that wasn't requested. This 'helpful' overengineering creates bloat and maintenance burden. Address it by being explicit: 'Keep solutions simple. Only make changes that are directly requested. Don't add features beyond what was asked.' The fix is prompt engineering, not configuration.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude 4.x Prompting Best Practices",
              "url": "https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/claude-4-best-practices",
              "onlineUrl": "https://platform.claude.com/docs/en/build-with-claude/prompt-engineering/claude-4-best-practices",
              "section": "Overeagerness and file creation",
              "accessDate": "2026-01-25"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Claude Opus 4.5 has a tendency to overengineer by creating extra files, adding unnecessary abstractions, or building in flexibility that wasn't requested. If you're seeing this undesired behavior, add explicit prompting to keep solutions minimal: 'Avoid over-engineering. Only make changes that are directly requested.'"
          }
        ]
      }
    },
    {
      "questionNumber": 10,
      "questionText": "What is the checkpoint system in Claude Code and how do you use it?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "A debugging tool for viewing API calls",
        "Automatic code state saving before changes - press Esc twice or use /rewind to restore",
        "A manual save feature requiring explicit /checkpoint command",
        "A git integration for automatic commits"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Automatic code state saving before changes - press Esc twice or use /rewind to restore",
      "explanation": "WHY THIS MATTERS: Checkpoints are your safety net for Claude's edits. Every time Claude modifies code, the previous state is automatically saved. If something goes wrong, press Escape twice or use /rewind to restore - no manual saving required. This enables confident experimentation because you can always undo. Note: checkpoints only apply to Claude's edits, not user modifications or bash commands.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Enabling Claude Code to Work More Autonomously",
              "url": "https://www.anthropic.com/news/enabling-claude-code-to-work-more-autonomously",
              "onlineUrl": "https://www.anthropic.com/news/enabling-claude-code-to-work-more-autonomously",
              "section": "Checkpoints",
              "accessDate": "2026-02-03"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Checkpoints automatically save code state before each change. Press Esc twice or use /rewind to restore. You can restore code, conversation, or both."
          }
        ]
      }
    },
    {
      "questionNumber": 11,
      "questionText": "What are the two boundaries enforced by Claude Code's sandboxing feature?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Memory isolation and CPU limits",
        "Filesystem isolation and network isolation",
        "Read-only mode and audit logging",
        "User isolation and process isolation"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Filesystem isolation and network isolation",
      "explanation": "WHY THIS MATTERS: Sandboxing confines Claude to specific directories (filesystem isolation) and approved network destinations (network isolation). This achieved 84% reduction in permission prompts internally at Anthropic while maintaining security. On Linux it uses bubblewrap, on macOS it uses seatbelt. Run /sandbox to configure. This is the foundation for safe autonomous operation.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Claude Code Sandboxing",
              "url": "https://www.anthropic.com/engineering/claude-code-sandboxing",
              "onlineUrl": "https://www.anthropic.com/engineering/claude-code-sandboxing",
              "section": "Overview",
              "accessDate": "2026-02-03"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Sandboxing enforces filesystem isolation (Claude can only access/modify specific directories) and network isolation (only connect to approved servers), achieving 84% reduction in permission prompts."
          }
        ]
      }
    },
    {
      "questionNumber": 12,
      "questionText": "What is a common Claude Code behavior that power users warn about during test-driven development?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Claude refuses to write tests",
        "Claude may modify tests to match buggy code instead of fixing the code",
        "Claude only writes unit tests, never integration tests",
        "Claude requires manual test file creation"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Claude may modify tests to match buggy code instead of fixing the code",
      "explanation": "WHY THIS MATTERS: Claude optimizes for passing tests, but sometimes takes the path of least resistance by weakening assertions rather than fixing bugs. This is why power users recommend reviewing ALL test modifications carefully. When tests fail, verify Claude is fixing the code, not the tests. Use TDD approach: write tests first, review them thoroughly before implementation.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "blog",
              "title": "Claude Code Gotchas",
              "url": "https://www.dolthub.com/blog/2025-06-30-claude-code-gotchas/",
              "onlineUrl": "https://www.dolthub.com/blog/2025-06-30-claude-code-gotchas/",
              "section": "Test Manipulation",
              "accessDate": "2026-02-03"
            },
            "authority": {
              "tier": 2,
              "organization": "Community",
              "confidence": 0.90
            },
            "quotedText": "Be very wary of changes to your test files. Claude writes failing tests, then modifies tests to match buggy code instead of fixing the code."
          }
        ]
      }
    },
    {
      "questionNumber": 13,
      "questionText": "When using --dangerously-skip-permissions for autonomous operation, what environment does Anthropic recommend?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Your main development machine with full internet access",
        "A container or VM without internet access",
        "A staging server with production data",
        "Any environment with version control"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "A container or VM without internet access",
      "explanation": "WHY THIS MATTERS: Autonomous operation without permission checks creates prompt injection and data exfiltration risks. Anthropic explicitly recommends using --dangerously-skip-permissions 'in a container without internet access.' Container isolation limits blast radius, and network isolation prevents data exfiltration. Version control alone isn't sufficient protection against malicious or unintended operations.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Security",
              "url": "https://code.claude.com/docs/en/security",
              "onlineUrl": "https://code.claude.com/docs/en/security",
              "section": "Autonomous Mode",
              "accessDate": "2026-02-03"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Use --dangerously-skip-permissions only in a container without internet access where damage is contained."
          }
        ]
      }
    },
    {
      "questionNumber": 14,
      "questionText": "What is the purpose of managed-settings.json in enterprise Claude Code deployments?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Store user preferences that can be customized",
        "Enforce organization-wide policies that cannot be overridden by local settings",
        "Cache API responses for faster performance",
        "Store authentication tokens securely"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Enforce organization-wide policies that cannot be overridden by local settings",
      "explanation": "WHY THIS MATTERS: Enterprise deployments need consistent security policies across all users. Managed-settings.json files are deployed to system directories and cannot be overridden by developers. This ensures organization-wide tool permissions, file access restrictions, and MCP server configurations are enforced uniformly. Settings hierarchy: Enterprise policies > CLI flags > Local > Shared > User.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Settings",
              "url": "https://code.claude.com/docs/en/settings",
              "onlineUrl": "https://code.claude.com/docs/en/settings",
              "section": "Managed Settings",
              "accessDate": "2026-02-03"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.98
            },
            "quotedText": "Managed settings in /Library/Application Support/ClaudeCode/managed-settings.json (macOS) or /etc/claude-code/managed-settings.json (Linux) enforce organization-wide policies that cannot be overridden."
          }
        ]
      }
    },
    {
      "questionNumber": 15,
      "questionText": "Given permission config: allow: ['Bash'], ask: ['Bash(rm *)'], what happens when Claude tries to run 'rm -rf /tmp/test'?",
      "type": "multiple_choice",
      "required": true,
      "options": [
        "Executes without prompting (Bash is allowed)",
        "Permission prompt appears (content-level 'ask' takes precedence over tool-level 'allow')",
        "Command is blocked entirely",
        "Error due to conflicting rules"
      ],
      "correctAnswerIndex": 1,
      "correctAnswer": "Permission prompt appears (content-level 'ask' takes precedence over tool-level 'allow')",
      "explanation": "WHY THIS MATTERS: Understanding permission precedence is critical for safe configuration. As of v2.1.27, content-level rules take precedence over tool-level rules. This means allow: ['Bash'] grants general bash access, but ask: ['Bash(rm *)'] still prompts for rm commands. This layered approach lets you grant broad permissions while maintaining guardrails on dangerous operations.",
      "citations": {
        "correctAnswer": [
          {
            "source": {
              "type": "documentation",
              "title": "Claude Code Settings Reference",
              "url": "https://code.claude.com/docs/en/settings",
              "onlineUrl": "https://code.claude.com/docs/en/settings",
              "section": "Permission Configuration",
              "accessDate": "2026-02-13"
            },
            "authority": {
              "tier": 1,
              "organization": "Anthropic",
              "confidence": 0.95
            },
            "quotedText": "Permission rules are evaluated with content-level patterns taking precedence over tool-level rules. A content-level 'ask' rule like 'Bash(rm *)' will trigger a permission prompt even if the tool-level 'allow' includes 'Bash'."
          }
        ]
      }
    }
  ]
}
